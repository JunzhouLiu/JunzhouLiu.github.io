(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{295:function(t,e,n){"use strict";n.r(e);var i=n(0),r=Object(i.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"碎语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#碎语","aria-hidden":"true"}},[t._v("#")]),t._v(" 碎语")]),t._v(" "),n("p",[t._v("其实这道题是典型的"),n("code",[t._v("Huffman Tree")]),t._v(",最开始做的时候是用数组来实现队列的"),n("code",[t._v("FIFO")]),t._v("特性，但是提交后发现"),n("code",[t._v("O(N)")]),t._v("太高了，OJ总是报"),n("code",[t._v("TLE")]),t._v(",尝试优化未果之后，骆老师说堆排序试试，用"),n("code",[t._v("priority_queue")]),t._v("优先队列完美AC，堆排序的时间复杂度我们一般认为可以近似到"),n("code",[t._v("O(nlogn)")]),t._v("。emmm，不说废话了，开始讲正题。\n")]),t._v(" "),n("h1",{attrs:{id:"关于priority-queue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于priority-queue","aria-hidden":"true"}},[t._v("#")]),t._v(" 关于"),n("code",[t._v("priority_queue")])]),t._v(" "),n("p",[n("code",[t._v("priority_queue")]),t._v("在"),n("code",[t._v("#include <queue>")]),t._v("中，我们用之前先声明一下，值得提的是优先队列在使用的过程中是会自动排序的，这一点尤为重要。")]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("priority_queue <int> i;\npriority_queue <double> d;\npriority_queue <node> q;//结构体\npriority_queue <int,vector<int>,greater<int> > q;//greater升序\n//#include<vector>可以省略\npriority_queue <int,vector<int>,less<int> >q;//less降序\n")])])]),n("p",[t._v("我们先声明一个名为"),n("code",[t._v("q")]),t._v("的"),n("code",[t._v("priority_queue")])]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("priority_queue<int,vector<int>,greater<int> >q;//缺省升序\n")])])]),n("p",[t._v("则可以对其进行以下操作")]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("q.size();//返回队列q元素个数\nq.empty();//确定队列q是否为空，空则return 1，反之 return 0\nq.push(k);//在队列q的末尾插入（压入）元素k\nq.pop();//弹掉队列q的第一个元素\nq.top();//取出队列q的第一个元素\nq.back();//取出队列q的末尾元素\n")])])]),n("h1",{attrs:{id:"题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题目描述","aria-hidden":"true"}},[t._v("#")]),t._v(" 题目描述:")]),t._v(" "),n("p",[t._v("小明很想吃果子，正好果园果子熟了。在果园里，小明已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。小明决定把所有的果子合成一堆。 因为小明比较懒，为了省力气，小明开始想点子了:\n　　每一次合并，小明可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。小明在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n　　因为还要花大力气把这些果子搬回家，所以小明在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使小明耗费的体力最少，并输出这个最小的体力耗费值。\n　　例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以小明总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。\n"),n("strong",[t._v("输入描述:")]),t._v("\n第一行输入整数N(0< N< =10)表示测试数据组数。接下来每组测试数据输入包括两行，第一行是一个整数n(1<＝n<=12000)，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai(1<＝ai<=20000)是第i种果子的数目。\n"),n("strong",[t._v("输出描述:")]),t._v("\n每组测试数据输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。\n"),n("strong",[t._v("样例输入:")])]),t._v(" "),n("blockquote",[n("p",[t._v("1\n3\n1  2 9")])]),t._v(" "),n("p",[n("strong",[t._v("样例输出:")])]),t._v(" "),n("blockquote",[n("p",[t._v("15")])]),t._v(" "),n("h1",{attrs:{id:"使用数组模拟实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用数组模拟实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用数组模拟实现")]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/*time：3828ms memory：2024k*/\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\nlong long test(int queue[],int x) {\n    long long power=0;\n    int beg=1;\n    for(int i=1; i<x; i++) {\n        power+=queue[i]+queue[i-1];//最小的两个值相加\n        queue[i]+=queue[i-1];//更新[i]值，\n        queue[i-1]=0;//[i-1]置0；\n        sort(queue+beg,queue+x);//重新排序\n        beg++;\n    }\n    return power;\n}\n\nint main() {\n    int n;\n    int queue[12010];\n\tcin>>n;\n    while(n--) {\n        int _num;\n        cin>>_num;\n        for(int i=0; i<_num; i++) {\n            cin>>queue[i];\n        }\n        sort(queue,queue+_num);//排序\n        cout<<test(queue,_num)<<endl;\n    }\n    return 0;\n}\n")])])]),n("h1",{attrs:{id:"使用priority-queue实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用priority-queue实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用"),n("code",[t._v("priority_queue")]),t._v("实现")]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/*time：122ms memory：2168k*/\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin>>n;\n\twhile(n--) {\n\t\tint _num,a,b;\n\t\tlong long power=0;\n\t\tpriority_queue<int,vector<int>,greater<int> >q;//定义priority_queue\n\t\tcin>>_num;\n\t\tfor(int i=0; i<_num; i++) {\n\t\t\tint temp;\n\t\t\tcin>>temp;\n\t\t\tq.push(temp);//数据插入queue\n\t\t}\n\t\tif(q.size()==1) {\n\t\t\tcout<<power<<endl;\n\t\t\tbreak;//特殊值处理，为1时无需搬运\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\ta=q.top();//取出最小值\n\t\t\tq.pop();//弹出该值\n\t\t\tb=q.top();//取出队列最小值\n\t\t\tq.pop();//弹出该值\n\t\t\tpower+=(a+b);//计入体力\n\t\t\tif(!q.empty()) {\n\t\t\t\tq.push(a+b);\n\t\t\t\t//队列非空时压入队列 ，重新排序\n\t\t\t}\n\t\t}\n\t\tcout<<power<<endl;\n\t}\n\treturn 0;\n}\n")])])])])},[],!1,null,null,null);e.default=r.exports}}]);